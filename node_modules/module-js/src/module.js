import ResourceManager from 'resource-manager-js';
let Promise = require('es6-promise').Promise;
let runtime = require('handlebars/runtime');

/**
 * Takes a value and separates the number and unit into a key/value map.
 * @param v - The value
 * @returns {{num: Number, unit: string}} Returns the map
 * @private
 */
let getCssPropUnitMap = function (v) {
    v.trim();
    let num = v.match('[0-9\.]+'),
        unit = 'ms';

    num = num ? num[0] : '';
    if (num) {
        unit = v.split(num)[1];
        num = Number(num);
    }
    return {
        num: num,
        unit: unit
    };
};

/**
 * Converts a css timing unit value into milliseconds.
 * @param {string} val - The value string
 * @returns {string} Returns the timing unit value in milliseconds
 */
let convertCssTimeValueToMilliseconds = function (val) {
    let number = getCssPropUnitMap(val).num,
        unit = val.replace(number, '');
    if (unit === 's') {
        val = number * 1000;
    } else {
        val = number;
    }
    return val + 'ms';
};

/**
 * Takes a css property name and returns the javascript version of it.
 * @param {string} cssProp - The css property
 * @returns {string} Returns the javascript version
 * @private
 */
let getJsPropName = function (cssProp) {
    // convert to camelCase
    return cssProp.replace(/-([a-z])/g, function (letter) {
        return letter[1].toUpperCase();
    });
};

/**
 * Bubbles up each parent node of the element, triggering the callback on each element until traversal
 * either runs out of parent nodes, reaches the document element, or if callback returns a falsy value
 * @param {Function} callback - A callback that fires which gets passed the current element
 * @param {HTMLElement} [startEl] - The element where traversal will begin (including the passed element), defaults to current el
 */
let traverseEachParent = function (callback, startEl) {
    let parentNode = startEl;
    let predicate = null;
    // check if the node has classname property, if not, we know we're at the #document element
    while (parentNode && typeof parentNode.className === 'string') {
        predicate = callback(parentNode);
        if (predicate !== undefined && !predicate) {
            break;
        }
        parentNode = parentNode.parentNode;
    }
};


/**
 * A function that fires when the module's load() method is called
 * @callback Module~onLoad
 * @return {*} May return a promise when done
 */


/**
 * A function that fires when the module's show() method is called
 * which can be overridden by subclass custom implementations.
 * @callback Module~onShow
 * @return {*} May return a promise when done
 */

/**
 * A function that fires when the module's hide() method is called
 * which can be overridden by subclass custom implementations.
 * @callback Module~onHide
 */

/**
 * A function that fires when the module's enable() method is called
 * @callback Module~onEnable
 */

/**
 * A function that fires when the module's disable() method is called
 * @callback Module~onDisable
 */

/**
 * A function that fires when the error() method is called
 * @callback Module~onError
 * @param {Object} [e] - The error object that was triggered
 */

/**
 * @class Module
 * @description Base class that represents all modules of an App.
 */
export default class Module {

    /**
     * Initialization.
     * @param {HTMLElement} el - The module element
     * @param {Object} [options] - An object of options
     * @param {string} [options.loadedClass] - The class that will be applied to the module element when it is loaded
     * @param {string} [options.activeClass] - The class that will be applied to the module element when it is shown
     * @param {string} [options.disabledClass] - The class that will be applied to the module element when disabled
     * @param {string} [options.errorClass] - The class that will be applied to the module element when it has a load error
     * @param {Array|string} [options.styles] - Array of stylesheet urls or single url
     * @param {string|HTMLTemplateElement|HTMLElement} [options.template] - The template to load (can be url to html or handlebars file or html template, just an element, or an html string)
     * @param {Object|string} [options.data] - The data or url to the module's data
     * @param {Object} [options.requestOptions] - The request options to use when running the fetch method to get data
     * @param {Module~onLoad} [options.onLoad] - A function that fires when module's load() method is called
     * @param {Module~onShow} [options.onShow] - A function that fires when module is shown
     * @param {Module~onHide} [options.onHide] - A function that fires when module is hidden
     * @param {Module~onEnable} [options.onEnable] - A function that fires when module is enabled
     * @param {Module~onDisable} [options.onDisable] - A function that fires when module is disabled
     * @param {Module~onError} [options.onError] - A function that fires when module goes into error state
     * @param {Object} [options.helpers] - An object containing a mapping of handlebar helper ids (keys) to their functions (values) to use when handlebar compiling
     */
    constructor (el, options) {

        options = options || {};

        if (!el) {
            console.error("Module error: No element was passed to constructor");
        }

        this.el = el;

        let defaultOptions = {
            loadedClass: 'module-loaded',
            activeClass: 'module-active',
            disabledClass: 'module-disabled',
            errorClass: 'module-error',
            styles: [],
            template: "",
            data: null,
            requestOptions: null,
            onLoad: function (){},
            onShow: function (){},
            onHide: function (){},
            onEnable: function (){},
            onDisable: function (){},
            onError: function (){},
            helpers: {},
        };

        // we are adding default options to passed custom options
        // to ensure all expected options exist when instantiating sub classes
        for (let name in defaultOptions) {
            if (defaultOptions.hasOwnProperty(name)) {
                if (!options[name]) {
                    options[name] = defaultOptions[name];
                }
            }
        }

        this.options = options;

        // setup helpers
        for (let name in options.helpers) {
            if (options.helpers.hasOwnProperty(name)) {
                runtime.registerHelper(name, options.helpers[name]);
            }
        }

        this._handleElementInitialState();

        this.subModules = {};
        this.active = false;
        this.loaded = false;
        this._elChildren = [];
        this.loadStatus = 'notLoaded';

    }

    /**
     * Loads the module's styles, template, and data and applies loaded css classes and state.
     * @return {Promise}
     */
    load () {
        if (!this.loaded) {
            this.loadStatus = 'loading';
            // load all subModules
            let loadPromises = [];
            for (let key in this.subModules) {
                if (this.subModules.hasOwnProperty(key)) {
                    let view = this.subModules[key];
                     loadPromises.push(view.load());
                }
            }
            return Promise.all(loadPromises)
                .then(() => {
                    return this.getStyles(this.options.styles).then(() => {
                            return this.fetchData(this.options.data, this.options.requestOptions).then((data) => {
                                return this.getTemplate(data).then((nodes) => {
                                    nodes = nodes || [];
                                    let frag = document.createDocumentFragment();
                                    // hold reference to children to remove them later
                                    while (nodes.length) {
                                        // order matters here so we always start from the first node
                                        let node = nodes[0];
                                        this._elChildren.push(node);
                                        // appending child changes length of nodes array
                                        frag.appendChild(node);
                                    }
                                    this.el.appendChild(frag);
                                    this.loaded = true;
                                    this.loadStatus = 'loaded';
                                    if (this.el) {
                                        this.el.classList.add(this.options.loadedClass);
                                    }
                                    this.options.onLoad();
                                });
                        });
                    });
                })
                .catch((e) => {
                    this.error(e);
                    // throw error to reject promise
                    throw e;
                });
        } else {
            return Promise.resolve();
        }
    }

    /**
     * Makes a request to get the data for the module.
     * @param {string|Object} url - The url to fetch data from or data object
     * @param [options] - fetch options
     * @returns {*}
     */
    fetchData (url, options) {
        if (typeof url !== 'string') {
            return Promise.resolve(url);
        }
        return ResourceManager.fetchData(url, options);
    }

    /**
     * Gets the css files for the module.
     * @param cssUrl
     * @return {Promise}
     */
    getStyles (cssUrl) {
        return ResourceManager.loadCss(cssUrl);
    }

    /**
     * Gets the html template for the module.
     * @param {Object} [data] - The data to inject (if template is a handlebar file)
     * @returns {Promise} Returns a document fragment containing the contents of the template with the data injected
     */
    getTemplate (data) {
        let template = this.options.template || '';

        if (!template) {
            return Promise.resolve();
        }

        let isHandlebarFile = function (filePath) {
            if (filePath) {
                let frags = filePath.split('.');
                let ext = frags[frags.length -1];
                return ext === 'hbs';
            }
        };

        if (this._isHTMLTemplate(template)) {
            // template element
            // TODO: update to accommodate situations where the user wants to adoptNode instead of cloning it
            let tpl = document.importNode(template.content, true);
            return Promise.resolve(tpl.childNodes);
        } else if (template instanceof HTMLElement) {
            // already an html element
            let frag = document.createDocumentFragment();
            frag.appendChild(template);
            return Promise.resolve(frag.childNodes);
        } else {
            // html or handlebar file
            let tempDiv = document.createElement('div');
            return ResourceManager.loadTemplate(template, tempDiv, data).then((html) => {
                return tempDiv.childNodes;
            });
        }
    }

    /**
     * Checks if the provided template argument is indeed an html template element.
     * This is mainly for testing purposes where phantom is not aware of HTMLTemplateElement
     * @param template
     * @returns {boolean}
     * @private
     */
    _isHTMLTemplate (template) {
        return template instanceof HTMLTemplateElement;
    }

    /**
     * Triggers a load error on the module.
     * @param {Object} [err] - The error object to trigger
     * @return {Promise} Returns a promise when erroring operation is complete
     */
    error (err) {
        let e = err || new Error();

        this.el.classList.add(this.options.errorClass);

        this.errored = true;
        this.loaded = false;
        this.loadStatus = 'notLoaded';

        this.options.onError(e);
        return this.waitForTransition().then(() => {
            return e;
        });
    }

    /**
     * Enables the module.
     * @return {Promise}
     */
    enable () {
        let el = this.el;
        if (el) {
            el.classList.remove(this.options.disabledClass);
        }
        this.disabled = false;
        this.options.onEnable();
        return this.waitForTransition();
    }

    /**
     * Disables the module.
     * @return {Promise}
     */
    disable () {
        let el = this.el;
        if (el) {
            el.classList.add(this.options.disabledClass);
        }
        this.disabled = true;

        this.options.onDisable();
        return this.waitForTransition();
    }

    /**
     * Shows the module.
     * @return {Promise}
     */
    show () {
        let el = this.el;
        if (el) {
            el.classList.add(this.options.activeClass);
        }
        this.active = true;
        this.options.onShow();
        return this.waitForTransition();
    }

    /**
     * Hides the module.
     * @return {Promise}
     */
    hide () {
        let el = this.el;
        if (el) {
            el.classList.remove(this.options.activeClass);
        }
        this.active = false;
        this.options.onHide();
        return this.waitForTransition();
    }

    /**
     * Sets up element internally by evaluating its initial state.
     * @private
     */
    _handleElementInitialState () {
        let el = this.el;
        if (!el) {
            return;
        }
        if (el.classList.contains(this.options.disabledClass)) {
            this._origDisabled = true;
            this.disable();
        }

        if (el.classList.contains(this.options.errorClass)) {
            this._origError = true;
            this.error(new Error());
        }
    }

    /**
     * Restores the elements classes back to the way they were before instantiation.
     * @private
     */
    _resetElementInitialState () {
        let options = this.options,
            disabledClass = options.disabledClass,
            errorClass = options.errorClass;

        if (!this.el) {
            return;
        }
        if (this._origDisabled) {
            this.el.classList.add(disabledClass);
        } else {
            this.el.classList.remove(disabledClass);
        }

        if (!this._origError) {
            this.el.classList.remove(errorClass);
        } else {
            this.el.classList.add(errorClass);
        }
    }

    /**
     * Builds a transition promise that waits to resolve until the module el's CSS transition is completed (if applicable).
     * @returns {Promise} Returns a promise that resolves when the element has finished animating
     */
    waitForTransition () {
        let duration = this.getTransitionDuration();
        return new Promise((resolve) => {
            if (duration > 0) {
                setTimeout(resolve.bind(this, this.el), duration);
            } else {
                resolve(this.el);
            }
        });
    }

    /**
     * Gets the time is takes for the element to transition to its show state.
     * @returns {Number} Returns the total CSS transition time in milliseconds
     */
    getTransitionDuration () {
        let delayProp = this.getCssComputedProperty('transition-delay') || '0ms',
            durationProp = this.getCssComputedProperty('transition-duration') || '0ms',
            times = Array.isArray(durationProp) ? durationProp : [durationProp],
            delay = Array.isArray(delayProp) ? delayProp : [delayProp],
            highest = 0,
            map;

        times.push.apply(times, delay); // account for delay

        // calculate highest number of time
        times.forEach((value) => {
            value.split(',').forEach((v) => {
                v = convertCssTimeValueToMilliseconds(v);
                map = getCssPropUnitMap(v);
                if (map.num > highest) {
                    highest = map.num;
                }
            });
        });

        return highest;
    }

    /**
     * Gets the computed property of the element.
     * @param {string} prop - The name of the property to get
     * @returns {string} Returns the value of the property
     */
    getCssComputedProperty (prop) {
        let style = window.getComputedStyle(this.el);
        return style.getPropertyValue(prop) || this.el.style[getJsPropName(prop)];
    }

    /**
     * Gets the closest ancestor element that has a css class.
     * @param {string} className - The class name that the ancestor must have to match
     * @param {Element} startTarget - The element the method should start from
     */
    getClosestAncestorElementByClassName (className, startTarget) {
        let result = null;
        traverseEachParent((parent) => {
            if (parent.classList.contains(className)) {
                result = parent;
                return false;
            }
        }, startTarget || this.el.parentNode || this.el);
        return result;
    }

    /**
     * Destroys all nested views and cleans up.
     */
    destroy () {
        let subModules = this.subModules;

        for (let key in subModules) {
            if (subModules.hasOwnProperty(key) && subModules[key]) {
                subModules[key].destroy();
            }
        }
        this.subModules = {};
        this.active = false;
        this.loaded = false;
        this.errored = false;
        this.loadStatus = 'notLoaded';

        this.el.classList.remove(this.options.loadedClass);
        this.el.classList.remove(this.options.activeClass);

        this._resetElementInitialState();

        this._elChildren.forEach((el) => {
            if (this.el.contains(el)) {
                this.el.removeChild(el);
            }
        });
        this._elChildren = [];
    }

}
