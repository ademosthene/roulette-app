'use strict';
import sinon from 'sinon';
import assert from 'assert';
import Module from '../src/module';
import ResourceManager from 'resource-manager-js';
var Promise = require('es6-promise').Promise;
var runtime = require('handlebars/runtime');

describe('Module', function () {

    let resourceManagerFetchDataStub;
    let resourceManagerLoadCssStub;
    let resourceManagerLoadTemplateStub;
    let isHTMLTemplateStub;
    let importNodeStub;


    beforeEach(function () {
        resourceManagerLoadCssStub = sinon.stub(ResourceManager, 'loadCss');
        resourceManagerLoadCssStub.returns(Promise.resolve());
        resourceManagerFetchDataStub = sinon.stub(ResourceManager, 'fetchData');
        resourceManagerFetchDataStub.returns(Promise.resolve());
        resourceManagerLoadTemplateStub = sinon.stub(ResourceManager, 'loadTemplate');
        resourceManagerLoadTemplateStub.returns(Promise.resolve());
        isHTMLTemplateStub = sinon.stub(Module.prototype, '_isHTMLTemplate').returns(false);
        importNodeStub = sinon.stub(document, 'importNode');

    });

    afterEach(function () {
        resourceManagerLoadCssStub.restore();
        resourceManagerFetchDataStub.restore();
        resourceManagerLoadTemplateStub.restore();
        importNodeStub.restore();
        isHTMLTemplateStub.restore();
    });

    it('should not trigger onLoad() callback when load() has already been called and resolved', function () {
        var el = document.createElement("div");
        var options = {onLoad: sinon.spy()};
        var module = new Module(el, options);
        return module.load()
            .then(function () {
                assert.equal(options.onLoad.callCount, 1, 'on first load() call onLoad() was called');
                return module.load()
                    .then(function () {
                        assert.equal(options.onLoad.callCount, 1, 'on second load() call onLoad() was not called');
                        module.destroy();
                    });
            });
    });

    it('should trigger onLoad() callback when load() is called', function () {
        var options = {onLoad: sinon.spy()};
        var el = document.createElement("div");
        var module = new Module(el, options);
        return module.load()
            .then(function () {
                assert.equal(options.onLoad.callCount, 1);
                module.destroy();
            });
    });

    it('should set the module\'s "el" to the element passed in instantiation', function () {
        var el = document.createElement('div');
        var module = new Module(el);
        assert.deepEqual(module.el, el);
        module.destroy();
    });

    it('should set a custom option passed in on instantiation as the the module\'s "options" property', function () {
        var el = document.createElement('div');
        var val = '3892';
        var customOptions = {myOptions: val};
        var module = new Module(el, customOptions);
        assert.equal(module.options.myOptions, val);
        module.destroy();
    });

    it('should add module loaded css class when when load() call is successful', function () {
        var el = document.createElement('div');
        var module = new Module(el);
        return module.load()
            .then(function () {
                assert.ok(el.classList.contains('module-loaded'), 'on load() module loaded class was added');
                module.destroy();
            });
    });

    it('should add custom loaded css class when when load() call is successful', function () {
        var el = document.createElement('div');
        var customLoadedClass = 'my-custom-loaded-class';
        var module = new Module(el, {loadedClass: customLoadedClass});
        return module.load()
            .then(function () {
                assert.ok(el.classList.contains(customLoadedClass));
                module.destroy();
            });
    });

    it('should NOT add module loaded css class when when load() promise is rejected', function (done) {
        var error = new Error();
        var onLoadStub = sinon.stub(Module.prototype, 'load').returns(Promise.reject(error));
        var el = document.createElement('div');
        var module = new Module(el, {onLoad: onLoadStub});
        module.load()
            .catch(function () {
                assert.ok(!el.classList.contains('module-loaded'));
                module.destroy();
                onLoadStub.restore();
                done();
            });
    });


    it('should call onError callback with error passed to error()', function () {
        var error = new Error();
        var onErrorSpy = sinon.spy();
        var module = new Module(document.createElement("div"), {onError: onErrorSpy});
        return module.error(error)
            .then(function () {
                assert.deepEqual(onErrorSpy.args[0][0], error, 'onError() was called and passed error object as first parameter');
                module.destroy();
            });
    });

    it('should add module error css class when when error() is triggered', function () {
        var el = document.createElement('div');
        var module = new Module(el);
        return module.error()
            .then(function () {
                assert.ok(el.classList.contains('module-error'));
                module.destroy();
            });
    });

    it('should remove module error css class on destroy when error() has been triggered', function () {
        var el = document.createElement('div');
        var module = new Module(el);
        return module.error()
            .then(function () {
                module.destroy();
                assert.ok(!el.classList.contains('module-error'));
            });
    });

    it('should add error css class back on destroy if element had error class before instantiation', function () {
        var el = document.createElement('div');
        el.classList.add('module-error');
        var module = new Module(el);
        el.classList.remove('module-error');
        module.destroy();
        assert.ok(el.classList.contains('module-error'));
    });

    it('should call onShow callback when show() is called', function () {
        var onShowSpy = sinon.spy();
        var module = new Module(document.createElement("div"), {onShow: onShowSpy});
        return module.show()
            .then(function () {
                assert.deepEqual(onShowSpy.callCount, 1);
                module.destroy();
            });
    });

    it('should call onHide callback when hide() is called', function () {
        var onHideSpy = sinon.spy();
        var module = new Module(document.createElement("div"), {onHide: onHideSpy});
        return module.hide()
            .then(function () {
                assert.deepEqual(onHideSpy.callCount, 1);
                module.destroy();
            });
    });

    it('should add module disabled css class when when disable() is called', function () {
        var el = document.createElement('div');
        var module = new Module(el);
        return module.disable()
            .then(function () {
                assert.ok(el.classList.contains('module-disabled'));
                module.destroy();
            });
    });

    it('should call onDisable callback when disable() is called', function () {
        var disableSpy = sinon.spy();
        var module = new Module(document.createElement("div"), {onDisable: disableSpy});
        return module.disable()
            .then(function () {
                assert.deepEqual(disableSpy.callCount, 1);
                module.destroy();
            });
    });

    it('should remove module disabled css class when enable() is called after disabled()', function () {
        var el = document.createElement('div');
        var module = new Module(el);
        return module.disable().then(function () {
            return module.enable().then(function () {
                assert.ok(!el.classList.contains('module-disabled'));
                module.destroy();
            });
        });
    });

    it('should remove module disable css class on destroy when disable() has been triggered', function () {
        var el = document.createElement('div');
        var module = new Module(el);
        return module.disable()
            .then(function () {
                module.destroy();
                assert.ok(!el.classList.contains('module-disabled'));
            });
    });

    it('should add disabled css class back on destroy when enable() has been called if element had disabled class before instantiation', function () {
        var el = document.createElement('div');
        el.classList.add('module-disabled');
        var module = new Module(el);
        return module.enable()
            .then(function () {
                module.destroy();
                assert.ok(el.classList.contains('module-disabled'));
            });
    });

    it('should call disable() immediately if element has module disabled css class applied before instantiation', function () {
        var el = document.createElement('div');
        var disableSpy = sinon.spy();
        el.classList.add('module-disabled');
        var module = new Module(el, {onDisable: disableSpy});
        assert.equal(disableSpy.callCount, 1);
        module.destroy();
    });

    it('should call onEnable callback when enable() is called', function () {
        var onEnableSpy = sinon.spy();
        var module = new Module(document.createElement('div'), {onEnable: onEnableSpy});
        return module.enable()
            .then(function () {
                assert.deepEqual(onEnableSpy.callCount, 1, 'onEnable() was called');
                module.destroy();
            });
    });

    it('active boolean should return true when show() is called', function () {
        var module = new Module(document.createElement("div"));
        module.show();
        assert.equal(module.active, true);
        module.destroy();
    });

    it('active boolean should return false when hide() is called, after show()', function () {
        var module = new Module(document.createElement("div"));
        module.show();
        module.hide();
        assert.equal(module.active, false);
        module.destroy();
    });

    it('active boolean should return false when destroy() is called, after show()', function () {
        var module = new Module(document.createElement("div"));
        module.show();
        module.destroy();
        assert.equal(module.active, false);
    });

    it('active boolean should return false when initialized()', function () {
        var module = new Module(document.createElement("div"));
        assert.equal(module.active, false);
        module.destroy();
    });

    it('loaded boolean should return true after successful load()', function () {
        var module = new Module(document.createElement("div"));
        return module.load().then(function () {
            assert.equal(module.loaded, true);
            module.destroy();
        });
    });

    it('loaded boolean should return false when destroy() is called after load()', function () {
        var module = new Module(document.createElement("div"));
        module.load();
        module.destroy();
        assert.equal(module.loaded, false);
    });

    it('should resolve error() promise with first parameter passed to it', function () {
        var el = document.createElement('div');
        var module = new Module(el);
        var testErrorObj = {details: 'my error'};
        return module.error(testErrorObj).then(function (err) {
            assert.deepEqual(testErrorObj, err);
            module.destroy();
        });
    });

    it('should custom error passed to error, should be passed to onError callback', function () {
        var testErrorObj = {details: 'my passed error'};
        var onErrorSpy = sinon.spy();
        var el = document.createElement('div');
        var module = new Module(el, {onError: onErrorSpy});
        return module.error(testErrorObj).then(function () {
            assert.deepEqual(onErrorSpy.args[0][0], testErrorObj);
            module.destroy();
        });
    });

    it('getCssComputedProperty()', function() {
        var el = document.createElement('div');
        var module = new Module(el);
        var value = '300px';
        el.style.width = value;
        assert.equal(module.getCssComputedProperty('width'), value, 'calling getCssComputedProperty() returns correct value');
        module.destroy();
    });

    it('waitForTransition() when there is a single computed property', function(done) {
        var el = document.createElement('div');
        var module = new Module(el);
        var callbackSpy = sinon.spy();
        var highestTimeMilliseconds = 50;
        var promiseDelay = 20; // promise returned from waitForTransition has a slight delay we need to account for
        el.style.width = "0px";
        el.style.transitionProperty = 'width';
        el.style.transitionDelay = highestTimeMilliseconds + 'ms';
        el.style.width = "25px";
        module.waitForTransition().then(callbackSpy);
        assert.equal(callbackSpy.callCount, 0, 'after calling waitForTransition() on an element that has a transition delay, the callback is not fired immediately because the transition hasnt finished');
        window.setTimeout(function () {
            assert.equal(callbackSpy.callCount, 1, 'callback is fired after the transition delay time elapses');
            var highestTimeMilliseconds = 100;
            el.style.transitionDelay = '100ms';
            el.style.transitionDuration = highestTimeMilliseconds + 'ms';
            module.waitForTransition().then(callbackSpy);
            assert.equal(callbackSpy.callCount, 1, 'callback is NOT immediately fired after a call to waitForTransition(), because the appropriate time hasnt yet elapsed');
            window.setTimeout(function () {
                assert.equal(callbackSpy.callCount, 2, 'after setting the transition duration to a higher number than the transition delay, callback is fired after the transition duration time elapses');
                var highestTime = 0.3;
                var highestTimeMilliseconds = highestTime * 1000;
                el.style.transitionDelay = '100ms';
                el.style.transitionDuration = highestTime + 's';
                module.waitForTransition().then(callbackSpy);
                assert.equal(callbackSpy.callCount, 2, 'callback is NOT immediately fired after a call to waitForTransition(), because the appropriate time hasnt yet elapsed');
                window.setTimeout(function () {
                    assert.equal(callbackSpy.callCount, 3, 'callback is still fired after the transition duration time elapses, even when it uses a seconds unit with a time value lower than the milliseconds time value of the transition duration');
                    module.destroy();
                    done();
                },highestTimeMilliseconds + promiseDelay + 1);
            }, highestTimeMilliseconds + promiseDelay + 1);
        }, highestTimeMilliseconds + promiseDelay + 1);
    });

    it('waitForTransition() on element that has multiple computed transition properties', function(done) {
        var el = document.createElement('div');
        var module = new Module(el);
        var callbackSpy = sinon.spy();
        var highestTimeMilliseconds = 75;
        var promiseDelay = 20; // promise returned from waitForTransition has a slight delay we need to account for
        el.style.transitionDelay = [highestTimeMilliseconds + 'ms', '50ms'];
        module.waitForTransition().then(callbackSpy);
        assert.equal(callbackSpy.callCount, 0, 'callback is NOT immediately fired after a call to waitForTransition(), because the appropriate time hasnt yet elapsed');
        setTimeout(function () {
            assert.equal(callbackSpy.callCount, 1, 'waitForTransition() fires callback at the appropriate time when on an element that has multiple transition delays');
            var highestTimeMilliseconds = 100;
            el.style.transitionDuration = ['40ms', highestTimeMilliseconds + 'ms'];
            module.waitForTransition().then(callbackSpy);
            assert.equal(callbackSpy.callCount, 1, 'callback is NOT immediately fired after a call to waitForTransition(), because the appropriate time hasnt yet elapsed');
            setTimeout(function () {
                assert.equal(callbackSpy.callCount, 2, 'waitForTransition() fires callback at the appropriate time when on an element that has multiple transition durations');
                var highestTimeMilliseconds = 200;
                el.style.transitionDuration = ['100ms', '50ms'];
                el.style.transitionDelay = [highestTimeMilliseconds + 'ms', '50ms'];
                module.waitForTransition().then(callbackSpy);
                assert.equal(callbackSpy.callCount, 2, 'callback is NOT immediately fired after a call to waitForTransition(), because the appropriate time hasnt yet elapsed');
                setTimeout(function () {
                    assert.equal(callbackSpy.callCount, 3, 'waitForTransition() fires callback at the appropriate time when on an element that has multiples of both transition delays and durations');
                    var highestTime = 0.3;
                    var highestTimeMilliseconds = highestTime * 1000;
                    el.style.transitionDuration = ['100ms', '50ms'];
                    el.style.transitionDelay = ['100ms', highestTime + 's', '300ms'];
                    module.waitForTransition().then(callbackSpy);
                    assert.equal(callbackSpy.callCount, 3, 'callback is NOT immediately fired after a call to waitForTransition(), because the appropriate time hasnt yet elapsed');
                    setTimeout(function () {
                        assert.equal(callbackSpy.callCount, 4, 'waitForTransition() fires callback at the appropriate time when on an element that has multiples of both transition delays and durations, even when one has a seconds unit');
                        module.destroy();
                        done()
                    }, highestTimeMilliseconds + promiseDelay + 1);
                }, highestTimeMilliseconds + promiseDelay + 1);
            }, highestTimeMilliseconds + promiseDelay + 1);
        }, highestTimeMilliseconds + promiseDelay + 1);
    });

    it('calling fetchData() with url, should pass url to ResourceManager\'s fetchData()', function () {
        var module = new Module(document.createElement('div'));
        var url = 'http://my.com/test/url';
        return module.fetchData(url).then(function () {
            assert.equal(resourceManagerFetchDataStub.args[0][0], url);
            module.destroy();
        });
    });

    it('calling fetchData() with an object should return with same object and no call should be made to ResourceManager\'s fetchData()', function () {
        var module = new Module(document.createElement('div'));
        var data = {'my-name': "Tester McTesterson"};
        return module.fetchData(data).then(function (returnedData) {
            assert.deepEqual(returnedData, data, 'Passed data was returned correctly');
            assert.equal(resourceManagerFetchDataStub.callCount, 0, 'Resource Manager\'s fetchData() method was not called');
            module.destroy();
        });
    });

    it('should remove default active css class when hide() is called after show()', function () {
        var el = document.createElement('div');
        var module = new Module(el);
        return module.show().then(function () {
            return module.hide().then(function () {
                assert.ok(!el.classList.contains('module-active'));
                module.destroy();
            });
        });
    });

    it('should add default active css class when when show() is triggered', function () {
        var el = document.createElement('div');
        var module = new Module(el);
        return module.show()
            .then(function () {
                assert.ok(el.classList.contains('module-active'));
                module.destroy();
            });
    });

    it('should pass the data option to fetchData method when load is called', function () {
        var dataParam = 'blah';
        var el = document.createElement("div");
        var module = new Module(el, {data: dataParam});
        sinon.stub(module, 'fetchData').returns(Promise.resolve());
        return module.load()
            .then(function () {
                assert.equal(module.fetchData.args[0][0], dataParam);
                module.destroy();
            });
    });

    it('should resolve fetchData() and call ResourceManager\'s fetchData, when a data url string is passed into it', function () {
        var dataApiUrl = 'my/data/api';
        var el = document.createElement("div");
        var module = new Module(el);
        return module.fetchData(dataApiUrl)
            .then(function () {
                assert.equal(resourceManagerFetchDataStub.args[0][0], dataApiUrl);
                module.destroy();
            });
    });

    it('should resolve fetchData(), without calling ResourceManager\'s fetchData, when a data object is passed into it', function () {
        var dataObj = {my: 'data', isFly: true};
        var el = document.createElement("div");
        var module = new Module(el, {data: dataObj});
        return module.fetchData(dataObj)
            .then(function () {
                assert.equal(resourceManagerFetchDataStub.callCount, 0);
                module.destroy();
            });
    });

    it('should resolve fetchData() with the exact data object passed into it', function () {
        var dataObj = {my: 'data', isFly: true};
        var el = document.createElement("div");
        var module = new Module(el, {data: dataObj});
        return module.fetchData(dataObj)
            .then(function (returnedData) {
                assert.deepEqual(dataObj, returnedData);
                module.destroy();
            });
    });

    it('should resolve fetchData() and call ResourceManager\'s fetchData with same ajax options passed into it', function () {
        var dataApiUrl = 'my/data/api';
        var el = document.createElement("div");
        var fetchOptions = {my: 'options'};
        var module = new Module(el);
        return module.fetchData(dataApiUrl, fetchOptions)
            .then(function () {
                assert.deepEqual(resourceManagerFetchDataStub.args[0][1], fetchOptions);
                module.destroy();
            });
    });

    it('should call Resource Manager\'s loadTemplate with the template option passed in instantiation when load() is called', function () {
        var templateUrl = 'my/template/url';
        var el = document.createElement("div");
        var module = new Module(el, {template: templateUrl});
        return module.load().then(function () {
            assert.equal(resourceManagerLoadTemplateStub.args[0][0], templateUrl);
            module.destroy();
        });
    });

    it('should call getTemplate() with data passed in data option on load() call', function () {
        var el = document.createElement("div");
        var template = 'template.html';
        var myData = {my: 'templateData'};
        var module = new Module(el, {template: template, data: myData});
        var html = 'mypagediv';
        resourceManagerLoadTemplateStub.withArgs(template).returns(Promise.resolve(html));
        var loadTemplate = sinon.spy(module, 'getTemplate');
        return module.load().then(function () {
            assert.deepEqual(loadTemplate.args[0][0], myData);
            loadTemplate.restore();
            module.destroy();
        });
    });

    it('should call ResourceManager loadTemplate() with the options.template property on load() call', function () {
        var el = document.createElement("div");
        var template = 'template.html';
        var module = new Module(el, {template: template});
        var html = 'mypagediv';
        resourceManagerLoadTemplateStub.withArgs(template).returns(Promise.resolve(html));
        return module.load().then(function () {
            assert.equal(resourceManagerLoadTemplateStub.args[0][0], template);
            module.destroy();
        });
    });

    it('should insert the html element passed as template into the module element on load() and NOT make a call to ResourceManager\'s loadTemplate method ', function () {
        var templateEl = document.createElement('div');
        templateEl.innerHTML = 'mypagediv';
        var el = document.createElement("div");
        var module = new Module(el, {template: templateEl});
        return module.load().then(function () {
            assert.deepEqual(el.childNodes[0], templateEl);
            assert.equal(resourceManagerLoadTemplateStub.callCount, 0);
            module.destroy();
        });
    });

    it('should inject contents of HTMLTemplateElement provided in options after load() call and NOT make call to ResourceManager\'s loadTemplate method', function () {
        var template = document.createDocumentFragment();
        var templateDiv = document.createElement('div');
        template.appendChild(templateDiv);
        var el = document.createElement("div");
        isHTMLTemplateStub.returns(true);
        importNodeStub.returns(template);
        var module = new Module(el, {template: template});
        return module.load().then(function () {
            assert.deepEqual(el.children[0], templateDiv);
            assert.equal(resourceManagerLoadTemplateStub.callCount, 0);
            module.destroy();
        });
    });

    it('should register any helpers passed', function () {
        var templateData = {my: 'templateData'};
        var el = document.createElement("div");
        var helperFunc = function(value){return value};
        var handlebarsRegisterHelpersStub = sinon.stub(runtime, 'registerHelper');
        var module = new Module(el, {
            helpers: {
                myHelper: helperFunc
            }
        });
        assert.equal(handlebarsRegisterHelpersStub.args[0][0], 'myHelper');
        assert.deepEqual(handlebarsRegisterHelpersStub.args[0][1], helperFunc);
        handlebarsRegisterHelpersStub.restore();
        module.destroy();
    });

    it('should return the matching ancestor element that has the css class name passed to getClosestAncestorElementByClassName()', function() {
        var html = ' \n\r' +
            '<div>' +
            '<div class="test-child"></div>' +
            '</div>';
        var el = document.createElement('li');
        el.className = 'ancestor';
        el.setAttribute('data-more', 'more_data');
        el.innerHTML = html;
        var childEl = el.getElementsByClassName('test-child')[0];
        var module = new Module(childEl);
        assert.equal(module.getClosestAncestorElementByClassName('ancestor'), el);
        module.destroy();
    });

    it('should return the matching ancestor element of the second argument that has the css class name passed to getClosestAncestorElementByClassName()', function() {
        var html = ' \n\r' +
            '<div>' +
                '<div class="ancestor-child">' +
                    '<div class="target-child"></div>' +
                '</div>' +
            '</div>';
        var el = document.createElement('li');
        el.className = 'ancestor';
        el.setAttribute('data-more', 'more_data');
        el.innerHTML = html;
        var ancestorEl = el.getElementsByClassName('ancestor-child')[0];
        var targetChild = el.getElementsByClassName('target-child')[0];
        var module = new Module(ancestorEl);
        assert.equal(module.getClosestAncestorElementByClassName('ancestor-child', targetChild), ancestorEl);
        module.destroy();
    });

    it('should return falsy when passing the css class name of an ancestor element to getClosestAncestorElementByClassName() that does not exist', function() {
        var html = ' \n\r' +
            '<div>' +
            '<div class="test-child"></div>' +
            '</div>';
        var el = document.createElement('li');
        el.className = 'ancestor';
        el.setAttribute('data-more', 'more_data');
        el.innerHTML = html;
        var childEl = el.getElementsByClassName('test-child')[0];
        var module = new Module(childEl);
        assert.ok(!module.getClosestAncestorElementByClassName('nothing'));
        module.destroy();
    });

    it('should NOT return the source element when attempting to get an ancestor element with the same class', function() {
        var html = ' \n\r' +
            '<div>' +
            '<div class="test-child"></div>' +
            '</div>';
        var el = document.createElement('li');
        el.className = 'ancestor';
        el.setAttribute('data-more', 'more_data');
        el.innerHTML = html;
        var childEl = el.getElementsByClassName('test-child')[0];
        var module = new Module(childEl);
        assert.ok(!module.getClosestAncestorElementByClassName('test-child'));
        module.destroy();
    });

    it('should inject contents of getTemplate() adjacent to any elements that reside in module\'s element before load() call', function () {
        var templateEl = document.createElement('div');
        templateEl.innerHTML = 'mypagehtml';
        var el = document.createElement("div");
        var existingEl = document.createElement('div');
        el.appendChild(existingEl);
        var module = new Module(el, {template: templateEl});
        return module.load().then(function () {
            assert.ok(el.contains(existingEl));
            assert.ok(el.contains(templateEl));
            module.destroy();
        });
    });

    it('should add all default options to any custom options passed in', function () {
        var returnedOptions = {
            loadedClass: 'module-loaded',
            activeClass: 'module-active',
            disabledClass: 'module-disabled',
            errorClass: 'module-error',
            styles: [],
            template: "",
            data: null,
            onLoad: function (){},
            onShow: function (){},
            onHide: function (){},
            onEnable: function (){},
            onDisable: function (){},
            onError: function (){}
        };
        var el = document.createElement('div');
        var val = '3892';
        var customOptions = {myCustomValue: val};
        var module = new Module(el, customOptions);
        assert.equal(customOptions.loadedClass, returnedOptions.loadedClass);
        assert.equal(customOptions.activeClass, returnedOptions.activeClass);
        assert.equal(customOptions.disabledClass, returnedOptions.disabledClass);
        assert.equal(customOptions.errorClass, returnedOptions.errorClass);
        assert.deepEqual(customOptions.styles, returnedOptions.styles);
        assert.equal(customOptions.template, returnedOptions.template);
        assert.equal(customOptions.data, returnedOptions.data);
        assert.equal(typeof customOptions.onLoad, "function");
        assert.equal(typeof customOptions.onShow, "function");
        assert.equal(typeof customOptions.onHide, "function");
        assert.equal(typeof customOptions.onEnable, "function");
        assert.equal(typeof customOptions.onDisable, "function");
        assert.equal(typeof customOptions.onError, "function");
        assert.equal(customOptions.myCustomValue, val);
        module.destroy();
    });

    it('should pass constructor fetchOptions into ResourceManager\'s fetchData call on load', function () {
        var templateUrl = 'my/template/url';
        var el = document.createElement("div");
        resourceManagerLoadTemplateStub.returns(Promise.resolve(undefined));
        var testRequestOptions = {key: true, my: 'nameistest'};
        var module = new Module(el, {template: templateUrl, requestOptions: testRequestOptions, data: 'my/data/api'});
        return module.load().then(function () {
            assert.deepEqual(resourceManagerFetchDataStub.args[0][1], testRequestOptions);
            module.destroy();
        });
    });

    it('should throw error and reject promise if ResourceManager\'s fetchData call rejects', function (done) {
        var templateUrl = 'my/template/url';
        var el = document.createElement("div");
        resourceManagerLoadTemplateStub.returns(Promise.resolve(undefined));
        var error = new Error('my error');
        resourceManagerFetchDataStub.returns(Promise.reject(error));
        var testRequestOptions = {key: true, my: 'nameistest'};
        var module = new Module(el, {template: templateUrl, requestOptions: testRequestOptions, data: 'my/data/api'});
        module.load().catch(function (err) {
            assert.deepEqual(err, error);
            module.destroy();
            done();
        });
    });

    it('should call error and set errored property to "true" if ResourceManager\'s loadCss call rejects', function (done) {
        var el = document.createElement("div");
        var error = new Error('my error');
        resourceManagerLoadCssStub.returns(Promise.reject(error));
        var module = new Module(el);
        var moduleLoadErrorSpy = sinon.spy(module, 'error');
        assert.ok(!module.errored);
        assert.equal(moduleLoadErrorSpy.callCount, 0);
        module.load().catch(function () {
            assert.deepEqual(moduleLoadErrorSpy.args[0][0], error);
            assert.ok(module.errored);
            module.destroy();
            done();
        });
    });

    it('should call error and set errored property to "true" if ResourceManager\'s fetchData call rejects', function (done) {
        var el = document.createElement("div");
        var error = new Error('my error');
        resourceManagerFetchDataStub.returns(Promise.reject(error));
        var module = new Module(el, {data: 'path/to/data'});
        var moduleLoadErrorSpy = sinon.spy(module, 'error');
        assert.ok(!module.errored);
        assert.equal(moduleLoadErrorSpy.callCount, 0);
        module.load().catch(function () {
            assert.deepEqual(moduleLoadErrorSpy.args[0][0], error);
            assert.ok(module.errored);
            module.destroy();
            done();
        });
    });

    it('should call error and set errored property to "true" if ResourceManager\'s loadTemplate call rejects', function (done) {
        var el = document.createElement("div");
        var error = new Error('my error');
        resourceManagerLoadTemplateStub.returns(Promise.reject(error));
        var module = new Module(el, {data: 'path/to/data', template: 'tpl.html'});
        var moduleLoadErrorSpy = sinon.spy(module, 'error');
        assert.ok(!module.errored);
        assert.equal(moduleLoadErrorSpy.callCount, 0);
        module.load().catch(function () {
            assert.deepEqual(moduleLoadErrorSpy.args[0][0], error);
            assert.ok(module.errored);
            module.destroy();
            done();
        });
    });

    it('should remove active class when destroyed', function () {
        var el = document.createElement('div');
        var activeClass = 'my-custom-active-class';
        var module = new Module(el, {activeClass: activeClass});
        return module.load().then(function () {
            // call show to add active class
            return module.show().then(() => {
                assert.ok(el.classList.contains(activeClass));
                module.destroy();
                assert.ok(!el.classList.contains(activeClass));
            });
        });
    });

    it('loadStatus should return "notLoaded" on instantiation', function () {
        var module = new Module(document.createElement("div"));
        assert.equal(module.loadStatus, 'notLoaded');
        module.destroy();
    });

    it('loadStatus should return "loaded" after successful loaded()', function () {
        var module = new Module(document.createElement("div"));
        return module.load().then(function () {
            assert.equal(module.loadStatus, 'loaded');
            module.destroy();
        });
    });

    it('loadStatus should return "notLoaded" when destroy() is called after load()', function () {
        var module = new Module(document.createElement("div"));
        module.load();
        module.destroy();
        assert.equal(module.loadStatus, 'notLoaded');
    });

    it('loadStatus should return "loading" when load() is called but has not yet resolved', function () {
        var module = new Module(document.createElement("div"));
        module.load();
        assert.equal(module.loadStatus, 'loading');
        module.destroy();
    });

    it('loadStatus should return "notLoaded" when load promise is rejected', function (done) {
        var error = new Error();
        var onLoadStub = sinon.stub(Module.prototype, 'load').returns(Promise.reject(error));
        var module = new Module(document.createElement("div"));
        module.load().catch(() => {
            module.destroy();
            assert.equal(module.loadStatus, 'notLoaded');
            onLoadStub.restore();
            done();
        });
    });
});
